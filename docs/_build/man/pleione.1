.\" Man page generated from reStructuredText.
.
.TH "PLEIONE" "1" "Jan 30, 2019" "" "pleione"
.SH NAME
pleione \- pleione Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Pleione is a python3 package that implement methods that are common to
traditional modeling frameworks, and apply them to analyze Rule\-Based Models.
.sp
Here you’ll find the necessary documentation to install and use the methods in
Pleione. At the moment, Pleione parameterizes Rule\-Based Models written
either in \fIBioNetGen\fP (\fI\%BioNetGen\fP) or \fIkappa\fP language (\fI\%Kappa\fP). Models are
simulated with BNG2 (\fI\%BioNetGen2\fP), NFsim (\fI\%NFsim\fP), KaSim (\fI\%KaSim\fP), or
PISKaS (\fI\%PISKaS\fP). Please contact us or write an issue to include your
favorite stochastic simulator to Pleione (\fI\%https://github.com/glucksfall/pleione/issues\fP).
.sp
Pleione implements a Genetic Algorithm with elitism, on the
contrary to BioNetFit (\fI\%BioNetFit\fP) that implements a parents selection within
a distribution probability that is inverse to the rank. Nonetheless, Pleione’s
methods to parameterize Rule\-Based Models include both, a uniform or inverse to the rank
probability to select models from within an elite or all models.
.sp
The plan to add methods into Pleione includes a sensitivity analysis and a
parameterization employing a Particle Swarm Optimization protocol. You
could write us if you wish to add methods into pleione or aid in the development
of them.
.SH INSTALLATION
.sp
There are two different ways to install pleione:
.INDENT 0.0
.IP 1. 3
\fBInstall pleione natively (Recommended).\fP
.sp
\fIOR\fP
.IP 2. 3
\fBClone the Github repository.\fP If you are familiar with git, pleione can
be cloned and the respective folder added to the python path. Further details
are below.
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed Help?\fP
If you run into any problems with installation, please visit our chat room:
\fI\%https://gitter.im/glucksfall/pleiades\fP
.UNINDENT
.UNINDENT
.SS Option 1: Install pleione natively on your computer
.sp
The recommended approach is to use system tools, or install them if
necessary. To install python packages, you could use pip, or download
the package from \fI\%python package index\fP\&.
.INDENT 0.0
.IP 1. 3
\fBInstall with system tools\fP
.sp
With pip, you simple need to execute and pleione will be installed on
\fB$HOME/.local/lib/python3.6/site\-packages\fP folder or similar.
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
pip3 install \-i https://test.pypi.org/simple/ pleione \-\-user
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you have system rights, you could install pleione for all users with
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
sudo \-H pip3 install \-i https://test.pypi.org/simple/ pleione
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 2. 3
\fBDownload from python package index\fP
.sp
Alternatively, you could download the package (useful when pip fails to
download the package) and then install with pip. For instance:
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
pip3 install \-i https://test.pypi.org/simple/ pleione \-\-user
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
\fBWhy Python3?\fP:
Pleione is intended to be used with python3, despite the lack of
incompatible functions with python2, because the latter won’t receive
further development past 2020. Although, the code could be optimize with
specific python3 functions over dictionaries, therefore making incompatible
with python2.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
\fBpip, Python and Anaconda\fP:
Be aware which pip you invoque. You could install pip3 with
\fBsudo apt\-get install python3\-pip\fP if you have system rights, or
install python3 from source, and adding \fB<python3 path>/bin/pip3\fP to the
path, or linking it in a directory like \fB$HOME/bin\fP which is commonly
added to the path at system login. Please be aware that, if you installed
Anaconda, pip could be linked to the Anaconda specific version of pip, which
will install pleione into Anaconda’s installation folder.
Type \fBwhich pip\fP or \fBwhich pip3\fP to find out the source of pip, and type
\fBpython \-m site\fP or \fBpython3 \-m site\fP to find out where is more likely
pleione would be installed.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Option 2: Clone the Github repository
.INDENT 0.0
.IP 1. 3
\fBClone with git\fP
.sp
The source code is uploaded and maintained through Github at
\fI\%https://github.com/glucksfall/pleione\fP\&. Therefore, you could clone the
repository locally, and then add the folder to the \fBPYTHONPATH\fP\&. Beware
that you should install the \fIpandas\fP package (\fI\%pandas\fP) by any means.
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/glucksfall/pleione /opt
echo export PYTHONPATH="\e$PYTHONPATH:/opt/pleione" >> $HOME/.profile
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 3.0
.INDENT 3.5
Adding the path to \fB$HOME/.profile\fP allows python to find the package
installation folder after each user login. Similarly, adding the path to
\fB$HOME/.bashrc\fP allows python to find the package after each terminal
invocation.
.UNINDENT
.UNINDENT
.UNINDENT
.SH PARAMETERS ESTIMATION
.sp
Pleione’s parameterization methods rely on Computational Load Distribution. The
naïve approach is to use the python’s \fImultiprocessing\fP API and each simulation
distributed within the Pool of available (minus one) cores. This approach would
make pleione’s methods compatible with Microsoft Windows and Apple OS X.
However, to take fully advantage of High\-Performance Computing architectures,
pleione’s methods rely on SLURM –\fISimple Linux Utility for Resource
Management\fP– (\fI\%SLURM\fP) to distribute simulations through your infrastructure,
remote infrastructures, and cloud services like Google Compute Engine, Microsoft
Azure, and Amazon Elastic Compute Cloud.
.sp
Up to date, pleione’s parameterization methods rely on 4 simulations engines:
KaSim and PISKaS simulate \fIkappa\fP language models. Unlike KaSim, PISKaS is able
to simulate multiple compartment models distributing the calculation of each
compartment through multiple cores. In the other hand, BioNetGen2 and NFsim
simulate \fIBioNetGen\fP language models. Despite KaSim and PISKaS, BioNetGen2 does
not provide a Command\-Line Interface to especify simulation parameters and
rather, the simulation parameters (e.g. time to simulation, number of points to
report, …) must be given inside the model specification. Moreover, you need to
especify the simulation engine to use: Deterministic simulation through \fICVODE\fP,
the Stochastic Simulation Algorithm \fISSA\fP, Exact Hybrid Particle/Population
Algorithm \fIHPP\fP, and the Partition\-Leap Algorithm \fIPLA\fP\&. Moreover, NFsim could
be used by BioNetGen2 to simulate models or called externally after creating the
model xml especification with BioNetGen2 –xml option.
.sp
Because the software requirements and differences, we provide specific
documentation to all of them rather than provide common guidelines and then
stating the differences.
.sp
Parameterization of kappa\-language Rule\-Based Models
.SS Parameterization with KaSim
.INDENT 0.0
.IP 1. 3
\fBPrepare the model\fP
.sp
Pleione parmeterization methods find which variables will be calibrated using
the symbol \fB//\fP (doble slash, as C/C++) followed by:
.INDENT 3.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
An initial distribution type: \fBuniform\fP, \fBloguniform\fP, \fBlognormal\fP
.IP \(bu 2
An initial search space: \fB[min max]\fP or \fB[mean standard_deviation]\fP
in the case \fBlognormal\fP was selected.
.IP \(bu 2
A type of mutation: \fBuniform\fP or \fBloguniform\fP to use a new search
space; or \fBfactor\fP to perform a local mutation search
.IP \(bu 2
A search space for mutated parameters: \fB[min max]\fP or
\fB[probability fold_change]\fP
.IP \(bu 2
An optional mutation rate per parameter. Without it, a global mutation
rate is used.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For instace:
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
%var: \(aqKD1__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm1__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqK2RT__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm2__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkphos__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkdephos__FREE__\(aq 1.000000e+00 // loguniform[0.01 100] factor[0.2 0.1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
or the following configuration if the model is written in syntax 3 (KaSim v3):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
%var: \(aqKD1__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm1__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqK2RT__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm2__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkphos__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkdephos__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBFactor mutation:\fP This type of mutation strategy comes from BioNetFit and
selects a random value from the range \fB0.9 * old_value, 1.1 * old_value\fP
if the declared value is \fB0.1\fP with probability \fB0.2\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare the data files\fP
.sp
KaSim produce simulations files with the following format. Please prepare
data files with the same format to avoid incompatibilities.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"[T]","RLbonds","pR"
600.,0,355.3
610.,114.072,356.44
620.,139.1838,349.96
630.,149.1534,343.98
640.,156.8684,342.6
650.,156.788,335.62
660.,163.6668,337.48
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBAbout the example model:\fP The model has three parts: An equilibration of
600 seconds, then the model is modified to add a quantity of \fBL(r)\fP agents,
and then perform the actual simulation for 60 seconds. Despite BNG2 and NFsim,
KaSim reports the whole simulation, so to compare effectively, we must offset
the time of the experimental data by 600.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare a sbatch configuration file\fP
.sp
Use the following code as template to make a shell script and queue it with
sbatch. Note that the \fBexport\fP statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \fBpython3\fP redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/sh

#SBATCH \-\-no\-requeue
#SBATCH \-\-partition=cpu

#SBATCH \-\-nodes=1
#SBATCH \-\-ntasks=1
#SBATCH \-\-cpus\-per\-task=1

#SBATCH \-\-job\-name=pleione\-kasim
#SBATCH \-\-output=stdout.txt
#SBATCH \-\-error=stderr.txt

export PYTHONPATH="$PYTHONPATH:$HOME/opt/git\-glucksfall\-pleione\-master"

MODEL=pysbmodel\-example6\-kasim.kappa
FINAL=660
STEPS=10 # KaSim interprets as the period, not how many points to report!

PARTITION=$SLURM_JOB_PARTITION
DATA=../exp\-data/kasim/data\-*.txt

NUM_ITER=100
NUM_SIMS=10
POP_SIZE=100
POP_BEST=0

SWAP=0.5
RATE=0.5
ERROR="MWUT"
UTABLE=./ucrit.txt

python3 \-m pleione.kasim \-\-model=$MODEL \-\-final=$FINAL \-\-steps=$STEPS \e
\-\-iter=$NUM_ITER \-\-pops=$POP_SIZE \-\-sims=$NUM_SIMS \-\-best=$POP_BEST \e
\-\-data=$DATA \-\-rate=$RATE \-\-swap=$SWAP \-\-error=$ERROR \-\-crit=$UTABLE \e
\-\-slurm=$PARTITION \-\-syntax=4
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBsbatch or python multiproccesing?\fP To execute Pleione outside a SLURM
queue, simple execute the shell script with \fBsh\fP, \fBbash\fP or any shell
interpreter without the \fBslurm\fP option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed help?\fP type \fBpython3 \-m pleione.kasim \-\-help\fP to find out the
available command options.
.UNINDENT
.UNINDENT
.SS Parameterization with PISKaS
.INDENT 0.0
.IP 1. 3
\fBPrepare the model\fP
.sp
Pleione parmeterization methods find which variables will be calibrated using
the symbol \fB#\fP (number sign, hash or pound sign) followed by:
.INDENT 3.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
An initial distribution type: \fBuniform\fP, \fBloguniform\fP, \fBlognormal\fP
.IP \(bu 2
An initial search space: \fB[min max]\fP or \fB[mean standard_deviation]\fP
in the case \fBlognormal\fP was selected.
.IP \(bu 2
A type of mutation: \fBuniform\fP or \fBloguniform\fP to use a new search
space; or \fBfactor\fP to perform a local mutation search
.IP \(bu 2
A search space for mutated parameters: \fB[min max]\fP or
\fB[probability fold_change]\fP
.IP \(bu 2
An optional mutation rate per parameter. Without it, a global mutation
rate is used.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For instace:
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
%var: \(aqKD1__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm1__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqK2RT__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkm2__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkphos__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
%var: \(aqkdephos__FREE__\(aq 1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBFactor mutation:\fP This type of mutation strategy comes from BioNetFit and
selects a random value from the range \fB0.9 * old_value, 1.1 * old_value\fP
if the declared value is \fB0.1\fP with probability \fB0.2\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare the data files\fP
.sp
PISKaS produce simulations files with the following format. Please prepare
data files with the same format, including the initial space in each row.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
example time \(aqRLbonds\(aq \(aqpR\(aq
 6.000000E+02 0 355.3
 6.100000E+02 114.072 356.44
 6.200000E+02 139.1838 349.96
 6.300000E+02 149.1534 343.98
 6.400000E+02 156.8684 342.6
 6.500000E+02 156.788 335.62
 6.600000E+02 163.6668 337.48
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBAn extra column name?\fP PISKaS produces one output for each compartment
declared in the model. Therefore, adding the name of the compartment as the
first column allows the code to identify the corresponding experimental data
with the simulated compartment and apply correctly the fitness function.
Finally, the model error is the sum of each fitness per compartment.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBAbout the example model:\fP The model has three parts: An equilibration of
600 seconds, then the model is modified to add a quantity of \fBL(r)\fP agents,
and then perform the actual simulation for 60 seconds. Despite BNG2 and NFsim,
PISKaS reports the whole simulation, so to compare effectively, we must offset
the time of the experimental data by 600.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare a sbatch configuration file\fP
.sp
Use the following code as template to make a shell script and queue it with
sbatch. Note that the \fBexport\fP statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \fBpython3\fP redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/sh

#SBATCH \-\-no\-requeue
#SBATCH \-\-partition=cpu

#SBATCH \-\-nodes=1
#SBATCH \-\-ntasks=1
#SBATCH \-\-cpus\-per\-task=1

#SBATCH \-\-job\-name=pleione\-piskas
#SBATCH \-\-output=stdout.txt
#SBATCH \-\-error=stderr.txt

export PYTHONPATH="$PYTHONPATH:$HOME/opt/git\-glucksfall\-pleione\-master"

MODEL=pysbmodel\-example6\-piskas.kappa
FINAL=660
STEPS=66

PARTITION=$SLURM_JOB_PARTITION
DATA=../exp\-data/piskas/data\-*.txt

NUM_ITER=100
NUM_SIMS=10
POP_SIZE=100
POP_BEST=0

SWAP=0.5
RATE=0.5
ERROR="MWUT"
UTABLE=./ucrit.txt

python3 \-m pleione.piskas \-\-model=$MODEL \-\-final=$FINAL \-\-steps=$STEPS \e
\-\-iter=$NUM_ITER \-\-pops=$POP_SIZE \-\-sims=$NUM_SIMS \-\-best=$POP_BEST \e
\-\-data=$DATA \-\-rate=$RATE \-\-swap=$SWAP \-\-error=$ERROR \-\-crit=$UTABLE \e
\-\-slurm=$PARTITION
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBsbatch or python multiproccesing?\fP To execute Pleione outside a SLURM
queue, simple execute the shell script with \fBsh\fP, \fBbash\fP or any shell
interpreter without the \fBslurm\fP option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed help?\fP type \fBpython3 \-m pleione.piskas \-\-help\fP to find out the
available command options.
.UNINDENT
.UNINDENT
.sp
Parameterization of BioNetGen language Rule\-Based Models
.SS Parameterization with BioNetGen2
.INDENT 0.0
.IP 1. 3
\fBPrepare the model\fP
.sp
Pleione parmeterization methods find which variables will be calibrated using
the symbol \fB#\fP (number sign, hash or pound sign) followed by:
.INDENT 3.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
An initial distribution type: \fBuniform\fP, \fBloguniform\fP, \fBlognormal\fP
.IP \(bu 2
An initial search space: \fB[min max]\fP or \fB[mean standard_deviation]\fP
in the case \fBlognormal\fP was selected.
.IP \(bu 2
A type of mutation: \fBuniform\fP or \fBloguniform\fP to use a new search
space; or \fBfactor\fP to perform a local mutation search
.IP \(bu 2
A search space for mutated parameters: \fB[min max]\fP or
\fB[probability fold_change]\fP
.IP \(bu 2
An optional mutation rate per parameter. Without it, a global mutation
rate is used.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For instace:
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
KD1__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
km1__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
K2RT__FREE__       1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
km2__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
kphos__FREE__      1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
kdephos__FREE__    1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBFactor mutation:\fP This type of mutation strategy comes from BioNetFit and
selects a random value from the range \fB0.9 * old_value, 1.1 * old_value\fP
if the declared value is \fB0.1\fP with probability \fB0.2\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare the data files\fP
.sp
BNG2 produce simulations files with the following format. Please prepare
data files with the same format, including the initial space in each row.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#          time         RLbonds              pR
 0.00000000E+00  0.00000000E+00  3.55300000E+02
 1.00000000E+01  1.14072000E+02  3.56440000E+02
 2.00000000E+01  1.39183800E+02  3.49960000E+02
 3.00000000E+01  1.49153400E+02  3.43980000E+02
 4.00000000E+01  1.56868400E+02  3.42600000E+02
 5.00000000E+01  1.56788000E+02  3.35620000E+02
 6.00000000E+01  1.63666800E+02  3.37480000E+02
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 3. 3
\fBPrepare a sbatch configuration file\fP
.sp
Use the following code as template to make a shell script and queue it with
sbatch. Note that the \fBexport\fP statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \fBpython3\fP redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/sh
export PYTHONPATH="$PYTHONPATH:$HOME/opt/git\-glucksfall\-pleione\-master"

#SBATCH \-\-no\-requeue
#SBATCH \-\-partition=cpu

#SBATCH \-\-nodes=1
#SBATCH \-\-ntasks=1
#SBATCH \-\-cpus\-per\-task=1

#SBATCH \-\-job\-name=pleione\-bng2
#SBATCH \-\-output=stdout.txt
#SBATCH \-\-error=stderr.txt

MODEL=pysbmodel\-example6\-bng2.bngl # the model should have the .bngl extension

PARTITION=$SLURM_JOB_PARTITION
DATA=../exp\-data/bng2/data\-*.txt

NUM_ITER=100
NUM_SIMS=10
POP_SIZE=100
POP_BEST=0

SWAP=0.5
RATE=0.5
ERROR="MWUT"
UTABLE=./ucrit.txt

python3 \-m pleione.bng2 \-\-model=$MODEL \e
\-\-iter=$NUM_ITER \-\-pops=$POP_SIZE \-\-sims=$NUM_SIMS \-\-best=$POP_BEST \e
\-\-data=$DATA \-\-rate=$RATE \-\-swap=$SWAP \-\-error=$ERROR \-\-crit=$UTABLE \e
\-\-slurm=$PARTITION
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBsbatch or python multiproccesing?\fP To execute Pleione outside a SLURM
queue, simple execute the shell script with \fBsh\fP, \fBbash\fP or any shell
interpreter without the \fBslurm\fP option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed help?\fP type \fBpython3 \-m pleione.bng2 \-\-help\fP to find out the
available command options.
.UNINDENT
.UNINDENT
.SS Parameterization with NFsim
.INDENT 0.0
.IP 1. 3
\fBPrepare the model\fP
.sp
Pleione parmeterization methods find which variables will be calibrated using
the symbol \fB#\fP (number sign, hash or pound sign) followed by:
.INDENT 3.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
An initial distribution type: \fBuniform\fP, \fBloguniform\fP, \fBlognormal\fP
.IP \(bu 2
An initial search space: \fB[min max]\fP or \fB[mean standard_deviation]\fP
in the case \fBlognormal\fP was selected.
.IP \(bu 2
A type of mutation: \fBuniform\fP or \fBloguniform\fP to use a new search
space; or \fBfactor\fP to perform a local mutation search
.IP \(bu 2
A search space for mutated parameters: \fB[min max]\fP or
\fB[probability fold_change]\fP
.IP \(bu 2
An optional mutation rate per parameter. Without it, a global mutation
rate is used.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For instace:
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
KD1__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
km1__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
K2RT__FREE__       1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
km2__FREE__        1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
kphos__FREE__      1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
kdephos__FREE__    1.000000e+00 # loguniform[0.01 100] factor[0.2 0.1]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBFactor mutation:\fP This type of mutation strategy comes from BioNetFit and
selects a random value from the range \fB0.9 * old_value, 1.1 * old_value\fP
if the declared value is \fB0.1\fP with probability \fB0.2\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare the data files\fP
.sp
NFsim produce simulations files with the following format. Please prepare
data files with the same format to avoid incompatibilities.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
time, RLbonds, pR
0.00000000E+00, 0.00000000E+00, 3.55300000E+02
1.00000000E+01, 1.14072000E+02, 3.56440000E+02
2.00000000E+01, 1.39183800E+02, 3.49960000E+02
3.00000000E+01, 1.49153400E+02, 3.43980000E+02
4.00000000E+01, 1.56868400E+02, 3.42600000E+02
5.00000000E+01, 1.56788000E+02, 3.35620000E+02
6.00000000E+01, 1.63666800E+02, 3.37480000E+02
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fBPrepare a sbatch configuration file\fP
.sp
Use the following code as template to make a shell script and queue it with
sbatch. Note that the \fBexport\fP statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \fBpython3\fP redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/sh

#SBATCH \-\-no\-requeue
#SBATCH \-\-partition=cpu

#SBATCH \-\-nodes=1
#SBATCH \-\-ntasks=1
#SBATCH \-\-cpus\-per\-task=1

#SBATCH \-\-job\-name=pleione\-nfsim
#SBATCH \-\-output=stdout.txt
#SBATCH \-\-error=stderr.txt

export PYTHONPATH="$PYTHONPATH:$HOME/opt/git\-glucksfall\-pleione\-master"

MODEL=pysbmodel\-example6\-nfsim.bngl # the model should have the .bngl extension
FINAL=60
STEPS=6

PARTITION=$SLURM_JOB_PARTITION
DATA=../exp\-data/nfsim/data\-*.txt

NUM_ITER=100
NUM_SIMS=10
POP_SIZE=100
POP_BEST=0

SWAP=0.5
RATE=0.5
ERROR="MWUT"
UTABLE=./ucrit.txt

python3 \-m pleione.nfsim \-\-model=$MODEL \-\-final=$FINAL \-\-steps=$STEPS \e
\-\-iter=$NUM_ITER \-\-pops=$POP_SIZE \-\-sims=$NUM_SIMS \-\-best=$POP_BEST \e
\-\-data=$DATA \-\-rate=$RATE \-\-swap=$SWAP \-\-error=$ERROR \-\-crit=$UTABLE \e
\-\-slurm=$PARTITION
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBsbatch or python multiproccesing?\fP To execute Pleione outside a SLURM
queue, simple execute the shell script with \fBsh\fP, \fBbash\fP or any shell
interpreter without the \fBslurm\fP option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed help?\fP type \fBpython3 \-m pleione.nfsim \-\-help\fP to find out the
available command options.
.UNINDENT
.UNINDENT
.sp
Common to all parameterization methods, there are 9 algebraic objective
functions and one statistical function already implemented in the code.
Moreover, the code sort the models by their rank and therefore, ranks can be
added and sorted again, making the possibility to use a Multiple Objective
Genetic Algorithm.
.SS Model Validation
.sp
Pleione’s parameter calibration scripts call an external script to calculate
fitness to experimental data. You could use one of the following script to
calculate the fitness of your parameterized model against an independent
experimental data set:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python3 \-m pleione.bng2\-doerror \-\-data foo \-\-sims bar \e
\-\-file output.txt \-\-error MWUT \-\-crit utable.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fIOR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python3 \-m pleione.kasim\-doerror \-\-data foo \-\-sims bar \e
\-\-file output.txt \-\-error MWUT \-\-crit utable.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fIOR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python3 \-m pleione.nfsim\-doerror \-\-data foo \-\-sims bar \e
\-\-file output.txt \-\-error MWUT \-\-crit utable.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fIOR\fP
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
python3 \-m pleione.piskas\-doerror \-\-data foo \-\-sims bar \e
\-\-file output.txt \-\-error MWUT \-\-crit utable.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBFitness Function\fP
Pleione currently support ten goodness of fit functions. To calculate more
than one function, include a comma\-only separated list such as \fBMWUT,SSQ\fP\&.
In doing so, this will calculate the contribution of both o more metrics to
the overall error and aid to validate of dischard a model calibration.
More information in Fitneess_Functions
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed Help?\fP
Type \fBpython3 \-m pleione.$STOCH_ENGINE\-doerror \-\-help\fP where
\fB$STOCH_ENGINE\fP can be the currently supported stochastic engines: BNG2,
NFsim, KaSim and PISKaS (all in lower cases, for instance \fBnfsim\-doerror\fP)
.UNINDENT
.UNINDENT
.SS Objective Functions
.sp
Common to all parameterization methods, there are 9 algebraic objective
functions and one statistical function already implemented in the code.
Moreover, the code sort the models by their rank and therefore, ranks can be
added and sorted again, making the possibility to use a Multiple Objective
Genetic Algorithm.
.SS Algebraic Objective Functions
.sp
Here are the formulas to calculate the error between multiple data sets and
simulations files.
.INDENT 0.0
.INDENT 2.0
.IP \(bu 2
.nf
\fBMean Square Error (MSE):\fP

.in +2
\eleft( \efrac{1}{m} \esum_{i=1}^{m} \emathrm{exp}_i \- \efrac{1}{n} \esum_{j=1}^{n} \emathrm{sim}_j \eright) ^{2}
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBMean Absolute Error (MAE):\fP

.in +2
\emathrm{abs} \eleft( \efrac{1}{m} \esum_{i=1}^{m} \emathrm{exp}_i \- \efrac{1}{n} \esum_{j=1}^{n} \emathrm{sim}_j \eright)
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBPair\-Wise Square Deviation (PWSD):\fP

.in +2
\efrac{1}{mn} \esum_{i=1}^{m} \esum_{j=1}^{n} \eleft({\emathrm{exp}_i \- \emathrm{sim}_j } \eright)^{2}
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBAbsolute Pair\-Wise Deviation (APWSD):\fP

.in +2
\efrac{1}{mn} \esum_{i=1}^{m} \esum_{j=1}^{n} \emathrm{abs} \eleft( \emathrm{exp}_i \- \emathrm{sim}_j \eright)
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBNormalized Pair\-Wise Square Deviation (NPWSD):\fP

.in +2
\efrac{1}{mn} \esum_{i=1}^{m} \esum_{j=1}^{n} \eleft( \efrac{ \emathrm{exp}_i \- \emathrm{sim}_j }{ \emathrm{exp}_i } \eright)^{2}
.in -2
.fi
.sp
.UNINDENT
.INDENT 2.0
.IP \(bu 2
.nf
\fBAbsolute Normalized Pair\-Wise Deviation (ANPWSD):\fP

.in +2
\efrac{1}{mn} \esum_{i=1}^{m} \esum_{j=1}^{n} \emathrm{abs} \eleft( \efrac{ \emathrm{exp}_i \- \emathrm{sim}_j }{ \emathrm{exp}_i } \eright)
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBSum of SQuares (SSQ):\fP

.in +2
\esum_{i=1}^{m} \esum_{j=1}^{n} \eleft({\emathrm{exp}_i \- \emathrm{sim}_j } \eright)^{2}
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBChi\-Square (CHISQ):\fP

.in +2
\esum_{i=1}^{m} \esum_{j=1}^{n} \eleft( \efrac{ \emathrm{exp}_i \- \emathrm{sim}_j }{ \esigma_{\emathrm{exp}} } \eright)^{2}
.in -2
.fi
.sp
.IP \(bu 2
.nf
\fBMean Normalized Square Error (MNSE):\fP

.in +2
\esum_{i=1}^{m} \esum_{j=1}^{n} \eleft( \efrac{ \emathrm{exp}_i \- \emathrm{sim}_j }{ \eoverline{\emathrm{exp}} } \eright)^{2}
.in -2
.fi
.sp
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed a different Objective Function?\fP The code that calculates the error
is separated from the main Genetic Algorithm. This make useful to encode
other Objective Functions if the already implemented does not apply to your
necessities. You could contact us to add your function to the pleione
package.
.UNINDENT
.UNINDENT
.SS Statistical Objective Functions
.sp
We implemented the Mann\-Whitney U\-test (MWUT) to calculate the error between
experimental data and simulations. The U\-test is a non\-parametric statistical
test that, within a confidence level, determine if a stochastic repeated
measurements is identical or not to another repeated measurements.
.sp
1. We count how many times experimental data (exp_i) are larger than
simulated values (sim_j):
.INDENT 0.0
.INDENT 3.5
.nf
\fBfor\fP i \emathrm{\e in\e } \emathrm{range} ( \emathrm{len}(exp) ):
.in +2
\fBfor\fP j \emathrm{\e in\e } \emathrm{range} ( \emathrm{len}(sim) ):
.in +2
\fBif\fP exp_{i} > sim_{j}:
.in +2
U_{exp} \egets U_{exp} + 1.0
.in -2
\fBelse if\fP exp_{i} < sim_{j}:
.in +2
U_{sim} \egets U_{sim} + 1.0
.in -2
\fBelse\fP:
.in +2
U_{exp} \egets U_{exp} + 0.5
U_{sim} \egets U_{sim} + 0.5
.in -2
.in -2
.in -2
.fi
.sp
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
We determine if U_{exp} is statistically significant:
.INDENT 3.0
.INDENT 3.5
.nf
\fBfor\fP i \emathrm{\e in\e } \emathrm{range} ( \emathrm{len}(exp) ):
.in +2
\fBif\fP \emathrm{len}(exp) \etimes \emathrm{len}(sim) \- \emathrm{min}(U_{exp}, U_{sim}) \eleq U_{\emathrm{critic}}:
.in +2
\emathrm{\etextit{null}\e hypothesis,\e }H_{0}\emathrm{,\e is\e rejected}
U_{\emathrm{model}} \egets U_{\emathrm{model}} + 1.0
.in -2
.in -2
.fi
.sp
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The U\-test is the only fitness function that has known limits: For a
\fIperfect\fP model, the U\-test is zero. A complete wrong model will have a
U_{model} equal to the number of Observables times the number of
experimental time points. For instance, the example model we use to compare
with BioNetFit has 2 Observables and 7 experimental time points, then a max
U_{model} equal to 14.
.UNINDENT
.UNINDENT
.SS Multiple Objective Functions
.sp
A Multiple Objective Function is build from two or more fitness functions.
Firstly, a fitness is calculated and all models ranked. Then, the next fitness.
Finally, the sum of ranks is use to rank agains the models.
.sp
Algoritmically:
.sp
.ce
rank_1 &= \emathrm{sort\e models\e following\e function\e 1} \e\e
&\emathrel{\evdots} \e\e
rank_n &= \emathrm{sort\e models\e following\e function\e n} \e\e
\e\e
rank_{MO} &= \emathrm{sort\e models\e following\e } (rank_1 + \eldots + rank_n)


.ce 0
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
We currently don’t provide weights to rank the models. Be aware that, if you
use multiple algebraic functions and the statistical fitness function, the
importance of the statistical function is diluited.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBNeed a different Objective Function?\fP
The code that calculates the error is separated from the main Genetic
Algorithm. This make useful to encode other Objective Functions if the
already implemented does not apply to your necessities. You could contact us
to add your function to the pleione package.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
\fBInstallation instructions:\fP
Instructions to install KaSim, BioNetGen, NFsim, and PISKaS are
available in their source code webpages. Nonetheless, here you will find
basic information to clone using git or download the software and install
it.
.sp
To install SLURM, you should have admin access to your infrastructure and an
UNIX\-based OS. Detailed instructions are provided here:
SLURM\-instructions
.UNINDENT
.UNINDENT
.SH COMPILING PYTHON3 FROM SOURCE
.sp
If you don’t have admin access to the cluster configuration, you could compile
and install python3 from source following these instructions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wget https://www.python.org/ftp/python/3.6.5/Python\-3.6.5.tgz \e
\-O ~/opt/ubuntu\-software/Python\-3.6.5.tgz
if [ \-d ~/opt/Python\-3.6.5 ]; then rm \-rf ~/opt/Python\-3.6.5; fi
tar xvzf ~/opt/ubuntu\-software/Python\-3.6.5.tgz \-C ~/opt
cd ~/opt/Python\-3.6.5
if [ \-f Makefile ]; then make clean; fi
if [ \-d $(HOME)/opt/python\-3.6.5 ]; then rm \-rf $(HOME)/opt/python\-3.6.5; fi
\&./configure \-\-prefix=$(HOME)/opt/python\-3.6.5
make
make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Don’t copy an installation folder from another machine since there may be
libraries incompatibilities. Instead, the code will download, configure,
compile, and install. To make accesible from anywhere, you could add an
alias into \fB~/.bashrc\fP or a symbolic in your \fB$HOME/bin\fP folder for
\fB$HOME/opt/python\-3.6.5/bin/python3\fP and \fBpip3\fP\&.
.UNINDENT
.UNINDENT
.sp
To install numpy and pandas use the following instructions, in order since some
pandas dependencies has also dependencies:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
wget https://files.pythonhosted.org/packages/71/90/ca61e203e0080a8cef7ac21eca199829fa8d997f7c4da3e985b49d0a107d/numpy\-1.14.3\-cp36\-cp36m\-manylinux1_x86_64.whl
wget https://files.pythonhosted.org/packages/dc/83/15f7833b70d3e067ca91467ca245bae0f6fe56ddc7451aa0dc5606b120f2/pytz\-2018.4\-py2.py3\-none\-any.whl
wget https://files.pythonhosted.org/packages/67/4b/141a581104b1f6397bfa78ac9d43d8ad29a7ca43ea90a2d863fe3056e86a/six\-1.11.0\-py2.py3\-none\-any.whl
wget https://files.pythonhosted.org/packages/cf/f5/af2b09c957ace60dcfac112b669c45c8c97e32f94aa8b56da4c6d1682825/python_dateutil\-2.7.3\-py2.py3\-none\-any.whl
wget https://files.pythonhosted.org/packages/69/ec/8ff0800b8594691759b78a42ccd616f81e7099ee47b167eb9bbd502c02b9/pandas\-0.23.0\-cp36\-cp36m\-manylinux1_x86_64.whl

pip3 install numpy\-1.14.3\-cp36\-cp36m\-manylinux1_x86_64.whl
pip3 install pytz\-2018.4\-py2.py3\-none\-any.whl
pip3 install six\-1.11.0\-py2.py3\-none\-any.whl
pip3 install python_dateutil\-2.7.3\-py2.py3\-none\-any.whl
pip3 install pandas\-0.23.0\-cp36\-cp36m\-manylinux1_x86_64.whl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you have admin access (and willing to compile python3 from source) you could
install the following dependencies:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
apt\-get install libssl\-dev zlib1g\-dev libncurses5\-dev \e
libncursesw5\-dev libreadline\-dev libsqlite3\-dev libgdbm\-dev \e
libdb5.3\-dev libbz2\-dev libexpat1\-dev liblzma\-dev tk\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Compiling python3 with all dependencies would make installation of packages
easier. Just follow the instructions:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip3 install pandas
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Installing pandas with pip will install numpy as its dependency.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Be sure you are calling pip3 after creating an alias or a symbolic link.
Without admin credentials, pip3 would fail to install pandas.
.UNINDENT
.UNINDENT
.SH INSTALLING SLURM IN YOUR MACHINE
.sp
To install SLURM you need admin access to the machine. Please follow this
instructions to start up running the workload manager, in the controller as well
in the controlled machines.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt\-get \-y install slurm\-wlm
sudo nano /etc/slurm\-llnl/slurm.conf

sudo chown \-R slurm:slurm /var/run/slurm\-llnl/
sudo chown \-R slurm:slurm /var/lib/slurm\-llnl/
sudo chown \-R slurm:slurm /var/log/slurm\-llnl/
sudo mkdir /var/spool/slurmd
sudo chown \-R slurm:slurm /var/spool/slurmd

sudo systemctl start slurmd
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Replace \fB$HOST_NAME\fP with your machine name that is going to act as the
controller. If you have multiple machines, this configuration file must be
identical and in all machines in the queue.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
### slurm.conf \- Slurm config file.

#ClusterName=$HOST_NAME
ControlMachine=$HOST_NAME
SlurmUser=slurm
AuthType=auth/munge

SlurmctldPidFile=/var/run/slurm\-llnl/slurmctld.pid
SlurmdPidFile=/var/run/slurm\-llnl/slurmd.pid
SlurmdSpoolDir=/var/lib/slurm\-llnl/slurmd
StateSaveLocation=/var/lib/slurm\-llnl/slurmctld

SwitchType=switch/none
ProctrackType=proctrack/pgid
TaskPlugin=task/none

MpiDefault=none
MaxJobCount=100000
MaxArraySize=64000

# TIMERS
SlurmdTimeout=300
InactiveLimit=0
MinJobAge=300
KillWait=30
Waittime=0

# SCHEDULING
SchedulerType=sched/backfill
SelectType=select/cons_res
SelectTypeParameters=CR_Core
FastSchedule=1

# LOGGING
SlurmctldDebug=3
SlurmctldLogFile=/var/log/slurm\-llnl/slurmctld.log
SlurmdDebug=3
SlurmdLogFile=/var/log/slurm\-llnl/slurmd.log

# COMPUTE NODES

# Here you add the machine hardware configurations
NodeName=$HOST_NAME Procs=8 Boards=1 SocketsPerBoard=1 CoresPerSocket=4 ThreadsPerCore=2 State=idle

# Here you add the machine(s) to a Partition
PartitionName=MyCluster Nodes=$HOST_NAME Default=yes MaxTime=INFINITE State=up
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Please refer to \fI\%SLURM\fP for advance configuration like limiting time, CPUs
and RAM for users or groups, to balance load in your cluster.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
Rodrigo Santibáñez
.SH COPYRIGHT
2018, Rodrigo Santibáñez
.\" Generated by docutils manpage writer.
.
