%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{pleione Documentation}
\date{Jul 12, 2018}
\release{}
\author{Rodrigo Santibáñez}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Pleione is a python3 package that implement methods that are common to
traditional modeling frameworks, and apply them to analyze Rule-Based Models.

Here you’ll find the necessary documentation to install and use the methods in
pleione. At the moment, pleione parameterizes Rule-Based Models written
either in \sphinxstyleemphasis{BioNetGen} (\sphinxhref{http://www.csb.pitt.edu/Faculty/Faeder/?page\_id=409}{BioNetGen}) or \sphinxstyleemphasis{kappa} language (\sphinxhref{https://www.kappalanguage.org/}{Kappa}). Models are
simulated with BNG2 (\sphinxhref{https://github.com/RuleWorld/bionetgen}{BioNetGen2}), NFsim (\sphinxhref{https://github.com/RuleWorld/nfsim}{NFsim}), KaSim (\sphinxhref{https://github.com/Kappa-Dev/KaSim}{KaSim}), or
PISKaS (\sphinxhref{https://github.com/DLab/PISKaS}{PISKaS}). Pleione implements a Genetic Algorithm with elitism, on the
contrary of BioNetFit (\sphinxhref{https://github.com/RuleWorld/BioNetFit}{BioNetFit}) that implements a parental selection within
an inverse distribution. Nonetheless, pleione’s methods to parameterize
Rule-Based Models include both, elitism and inverse methods.

The plan to add methods into pleione includes a sensitivity analysis and a
parameterization method employing a Particle Swarm Optimization protocol. You
could write us if you wish to add methods into pleione or aid in the development
of them.


\chapter{Installation}
\label{\detokenize{Installation:installation}}\label{\detokenize{Installation::doc}}
There are two different ways to install pleione:
\begin{enumerate}
\item {} 
\sphinxstylestrong{Install pleione natively (Recommended).}

\sphinxstyleemphasis{OR}

\item {} 
\sphinxstylestrong{Clone the Github repository.} If you are familiar with git, pleione can
be cloned and the respective folder added to the python path. Further details
are below.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need Help?}
If you run into any problems with installation, please visit our chat room:
\sphinxurl{https://gitter.im/glucksfall/pleiades}
\end{sphinxadmonition}


\section{Option 1: Install pleione natively on your computer}
\label{\detokenize{Installation:option-1-install-pleione-natively-on-your-computer}}
The recommended approach is to use system tools, or install them if
necessary. To install python packages, you could use pip, or download
the package from \sphinxhref{https://pypi.org/project/pleione/}{python package index}.
\begin{enumerate}
\item {} 
\sphinxstylestrong{Install with system tools}

With pip, you simple need to execute and pleione will be installed on
\sphinxcode{\sphinxupquote{\$HOME/.local/lib/python3.6/site-packages}} folder or similar.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install pleione \PYGZhy{}\PYGZhy{}user
\end{sphinxVerbatim}

If you have system rights, you could install pleione for all users with

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo \PYGZhy{}H pip3 install pleione
\end{sphinxVerbatim}

\item {} 
\sphinxstylestrong{Download from python package index}

Alternatively, you could download the package (useful when pip fails to
download the package) and then install with pip. For instance:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install pleione\PYGZhy{}0.1.dev1\PYGZhy{}py3\PYGZhy{}none\PYGZhy{}any.whl \PYGZhy{}\PYGZhy{}user
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Why Python3?}:
Pleione is intended to be used with python3, despite the lack of
incompatible functions with python2, because the latter won’t receive
further development past 2020. Although, the code could be optimize with
specific python3 functions over dictionaries, therefore making incompatible
with python2.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{pip, Python and Anaconda}:
Be aware which pip you invoque. You could install pip3 with
\sphinxcode{\sphinxupquote{sudo apt-get install python3-pip}} if you have system rights, or
install python3 from source, and adding \sphinxcode{\sphinxupquote{\textless{}python3 path\textgreater{}/bin/pip3}} to the
path, or linking it in a directory like \sphinxcode{\sphinxupquote{\$HOME/bin}} which is commonly
added to the path at system login. Please be aware that, if you installed
Anaconda, pip could be linked to the Anaconda specific version of pip, which
will install pleione into Anaconda’s installation folder.
Type \sphinxcode{\sphinxupquote{which pip}} or \sphinxcode{\sphinxupquote{which pip3}} to find out the source of pip, and type
\sphinxcode{\sphinxupquote{python -m site}} or \sphinxcode{\sphinxupquote{python3 -m site}} to find out where is more likely
pleione would be installed.
\end{sphinxadmonition}

\end{enumerate}


\section{Option 2: Clone the Github repository}
\label{\detokenize{Installation:option-2-clone-the-github-repository}}\begin{enumerate}
\item {} 
\sphinxstylestrong{Clone with git}

The source code is uploaded and maintained through Github at
\sphinxurl{https://github.com/glucksfall/pleione}. Therefore, you could clone the
repository locally, and then add the folder to the \sphinxcode{\sphinxupquote{PYTHONPATH}}. Beware
that you should install the \sphinxstyleemphasis{pandas} package (\sphinxhref{https://pandas.pydata.org/}{pandas}) by any means.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://github.com/glucksfall/pleione /opt
\PYG{n+nb}{echo} \PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}\PYGZdl{}PYTHONPATH:/opt/pleione\PYGZdq{}} \PYGZgt{}\PYGZgt{} \PYG{n+nv}{\PYGZdl{}HOME}/.profile
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Adding the path to \sphinxcode{\sphinxupquote{\$HOME/.profile}} allows python to find the package
installation folder after each user login. Similarly, adding the path to
\sphinxcode{\sphinxupquote{\$HOME/.bashrc}} allows python to find the package after each terminal
invocation.
\end{sphinxadmonition}

\end{enumerate}


\chapter{Parameters estimation}
\label{\detokenize{ParameterEstimation:parameters-estimation}}\label{\detokenize{ParameterEstimation::doc}}
Pleione’s parameterization methods rely on Computational Load Distribution. The
naïve approach is to use the python’s \sphinxstyleemphasis{multiprocessing} API and each simulation
distributed within the Pool of available (minus one) cores. This approach would
make pleione’s methods compatible with Microsoft Windows and Apple OS X.
However, to take fully advantage of High-Performance Computing architectures,
pleione’s methods rely on SLURM \textendash{}\sphinxstyleemphasis{Simple Linux Utility for Resource
Management}\textendash{} (\sphinxhref{https://slurm.schedmd.com/}{SLURM}) to distribute simulations through your infrastructure,
remote infrastructures, and cloud services like Google Compute Engine, Microsoft
Azure, and Amazon Elastic Compute Cloud.

Up to date, pleione’s parameterization methods rely on 4 simulations engines:
KaSim and PISKaS simulate \sphinxstyleemphasis{kappa} language models. Unlike KaSim, PISKaS is able
to simulate multiple compartment models distributing the calculation of each
compartment through multiple cores. In the other hand, BioNetGen2 and NFsim
simulate \sphinxstyleemphasis{BioNetGen} language models. Despite KaSim and PISKaS, BioNetGen2 does
not provide a Command-Line Interface to especify simulation parameters and
rather, the simulation parameters (e.g. time to simulation, number of points to
report, …) must be given inside the model specification. Moreover, you need to
especify the simulation engine to use: Deterministic simulation through \sphinxstyleemphasis{CVODE},
the Stochastic Simulation Algorithm \sphinxstyleemphasis{SSA}, Exact Hybrid Particle/Population
Algorithm \sphinxstyleemphasis{HPP}, and the Partition-Leap Algorithm \sphinxstyleemphasis{PLA}. Moreover, NFsim could
be used by BioNetGen2 to simulate models or called externally after creating the
model xml especification with BioNetGen2 \textendash{}xml option.

Because the software requirements and differences, we provide specific
documentation to all of them rather than provide common guidelines and then
stating the differences.

Parameterization of kappa-language Rule-Based Models


\section{Parameterization with KaSim}
\label{\detokenize{engines/kasim:parameterization-with-kasim}}\label{\detokenize{engines/kasim::doc}}\begin{enumerate}
\item {} 
\sphinxstylestrong{Prepare the model}

Pleione parmeterization methods find which variables will be calibrated using
the symbol \sphinxcode{\sphinxupquote{//}} (doble slash, as C/C++) followed by:
\begin{itemize}
\item {} 
An initial distribution type: \sphinxcode{\sphinxupquote{uniform}}, \sphinxcode{\sphinxupquote{loguniform}}, \sphinxcode{\sphinxupquote{lognormal}}

\item {} 
An initial search space: \sphinxcode{\sphinxupquote{{[}min max{]}}} or \sphinxcode{\sphinxupquote{{[}mean standard\_deviation{]}}}
in the case \sphinxcode{\sphinxupquote{lognormal}} was selected.

\item {} 
A type of mutation: \sphinxcode{\sphinxupquote{uniform}} or \sphinxcode{\sphinxupquote{loguniform}} to use a new search
space; or \sphinxcode{\sphinxupquote{factor}} to perform a local mutation search

\item {} 
A search space for mutated parameters: \sphinxcode{\sphinxupquote{{[}min max{]}}} or
\sphinxcode{\sphinxupquote{{[}probability fold\_change{]}}}

\item {} 
An optional mutation rate per parameter. Without it, a global mutation
rate is used.

\end{itemize}

For instace:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}KD1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}K2RT\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km2\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kphos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kdephos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 // loguniform\PYG{o}{[}\PYG{l+m}{0}.01 \PYG{l+m}{100}\PYG{o}{]} factor\PYG{o}{[}\PYG{l+m}{0}.2 \PYG{l+m}{0}.1\PYG{o}{]}
\end{sphinxVerbatim}

or the following configuration if the model is written in syntax 3 (KaSim v3):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}KD1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}K2RT\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km2\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kphos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kdephos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Factor mutation:} This type of mutation strategy comes from BioNetFit and
selects a random value from the range \sphinxcode{\sphinxupquote{0.9 * old\_value, 1.1 * old\_value}}
if the declared value is \sphinxcode{\sphinxupquote{0.1}} with probability \sphinxcode{\sphinxupquote{0.2}}.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare the data files}

KaSim produce simulations files with the following format. Please prepare
data files with the same format to avoid incompatibilities.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}[T]\PYGZdq{}},\PYG{l+s+s2}{\PYGZdq{}RLbonds\PYGZdq{}},\PYG{l+s+s2}{\PYGZdq{}pR\PYGZdq{}}
\PYG{l+m}{600}.,0,355.3
\PYG{l+m}{610}.,114.072,356.44
\PYG{l+m}{620}.,139.1838,349.96
\PYG{l+m}{630}.,149.1534,343.98
\PYG{l+m}{640}.,156.8684,342.6
\PYG{l+m}{650}.,156.788,335.62
\PYG{l+m}{660}.,163.6668,337.48
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{About the example model:} The model has three parts: An equilibration of
600 seconds, then the model is modified to add a quantity of \sphinxcode{\sphinxupquote{L(r)}} agents,
and then perform the actual simulation for 60 seconds. Despite BNG2 and NFsim,
KaSim reports the whole simulation, so to compare effectively, we must offset
the time of the experimental data by 600.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare a sbatch configuration file}

Use the following code as template to make a shell script and queue it with
sbatch. Note that the \sphinxcode{\sphinxupquote{export}} statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \sphinxcode{\sphinxupquote{python3}} redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}no\PYGZhy{}requeue}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}partition=cpu}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}ntasks=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task=1}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}job\PYGZhy{}name=pleione\PYGZhy{}kasim}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}output=stdout.txt}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}error=stderr.txt}

\PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}\PYG{l+s+s2}{:}\PYG{n+nv}{\PYGZdl{}HOME}\PYG{l+s+s2}{/opt/git\PYGZhy{}glucksfall\PYGZhy{}pleione\PYGZhy{}master}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nv}{MODEL}\PYG{o}{=}pysbmodel\PYGZhy{}example6\PYGZhy{}kasim.kappa
\PYG{n+nv}{FINAL}\PYG{o}{=}\PYG{l+m}{660}
\PYG{n+nv}{STEPS}\PYG{o}{=}\PYG{l+m}{10} \PYG{c+c1}{\PYGZsh{} KaSim interprets as the period, not how many points to report!}

\PYG{n+nv}{PARTITION}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}PARTITION}
\PYG{n+nv}{DATA}\PYG{o}{=}../exp\PYGZhy{}data/kasim/data\PYGZhy{}*.txt

\PYG{n+nv}{NUM\PYGZus{}ITER}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{NUM\PYGZus{}SIMS}\PYG{o}{=}\PYG{l+m}{10}
\PYG{n+nv}{POP\PYGZus{}SIZE}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{POP\PYGZus{}BEST}\PYG{o}{=}\PYG{l+m}{0}

\PYG{n+nv}{SWAP}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{RATE}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{ERROR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}MWUT\PYGZdq{}}
\PYG{n+nv}{UTABLE}\PYG{o}{=}./ucrit.txt

python3 \PYGZhy{}m pleione.kasim \PYGZhy{}\PYGZhy{}model\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MODEL} \PYGZhy{}\PYGZhy{}final\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}FINAL} \PYGZhy{}\PYGZhy{}steps\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}STEPS} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}iter\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}ITER} \PYGZhy{}\PYGZhy{}pops\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}SIZE} \PYGZhy{}\PYGZhy{}sims\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}SIMS} \PYGZhy{}\PYGZhy{}best\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}BEST} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}data\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}DATA} \PYGZhy{}\PYGZhy{}rate\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RATE} \PYGZhy{}\PYGZhy{}swap\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SWAP} \PYGZhy{}\PYGZhy{}error\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}ERROR} \PYGZhy{}\PYGZhy{}crit\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}UTABLE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}slurm\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PARTITION} \PYGZhy{}\PYGZhy{}syntax\PYG{o}{=}\PYG{l+m}{4}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{sbatch or python multiproccesing?} To execute Pleione outside a SLURM
queue, simple execute the shell script with \sphinxcode{\sphinxupquote{sh}}, \sphinxcode{\sphinxupquote{bash}} or any shell
interpreter without the \sphinxcode{\sphinxupquote{slurm}} option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need help?} type \sphinxcode{\sphinxupquote{python3 -m pleione.kasim -{-}help}} to find out the
available command options.
\end{sphinxadmonition}


\section{Parameterization with PISKaS}
\label{\detokenize{engines/piskas:parameterization-with-piskas}}\label{\detokenize{engines/piskas::doc}}\begin{enumerate}
\item {} 
\sphinxstylestrong{Prepare the model}

Pleione parmeterization methods find which variables will be calibrated using
the symbol \sphinxcode{\sphinxupquote{\#}} (number sign, hash or pound sign) followed by:
\begin{itemize}
\item {} 
An initial distribution type: \sphinxcode{\sphinxupquote{uniform}}, \sphinxcode{\sphinxupquote{loguniform}}, \sphinxcode{\sphinxupquote{lognormal}}

\item {} 
An initial search space: \sphinxcode{\sphinxupquote{{[}min max{]}}} or \sphinxcode{\sphinxupquote{{[}mean standard\_deviation{]}}}
in the case \sphinxcode{\sphinxupquote{lognormal}} was selected.

\item {} 
A type of mutation: \sphinxcode{\sphinxupquote{uniform}} or \sphinxcode{\sphinxupquote{loguniform}} to use a new search
space; or \sphinxcode{\sphinxupquote{factor}} to perform a local mutation search

\item {} 
A search space for mutated parameters: \sphinxcode{\sphinxupquote{{[}min max{]}}} or
\sphinxcode{\sphinxupquote{{[}probability fold\_change{]}}}

\item {} 
An optional mutation rate per parameter. Without it, a global mutation
rate is used.

\end{itemize}

For instace:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}KD1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}K2RT\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}km2\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kphos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\PYGZpc{}var: \PYG{l+s+s1}{\PYGZsq{}kdephos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}\PYGZsq{}} \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Factor mutation:} This type of mutation strategy comes from BioNetFit and
selects a random value from the range \sphinxcode{\sphinxupquote{0.9 * old\_value, 1.1 * old\_value}}
if the declared value is \sphinxcode{\sphinxupquote{0.1}} with probability \sphinxcode{\sphinxupquote{0.2}}.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare the data files}

PISKaS produce simulations files with the following format. Please prepare
data files with the same format, including the initial space in each row.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
example \PYG{n+nb}{time} \PYG{l+s+s1}{\PYGZsq{}RLbonds\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}pR\PYGZsq{}}
 \PYG{l+m}{6}.000000E+02 \PYG{l+m}{0} \PYG{l+m}{355}.3
 \PYG{l+m}{6}.100000E+02 \PYG{l+m}{114}.072 \PYG{l+m}{356}.44
 \PYG{l+m}{6}.200000E+02 \PYG{l+m}{139}.1838 \PYG{l+m}{349}.96
 \PYG{l+m}{6}.300000E+02 \PYG{l+m}{149}.1534 \PYG{l+m}{343}.98
 \PYG{l+m}{6}.400000E+02 \PYG{l+m}{156}.8684 \PYG{l+m}{342}.6
 \PYG{l+m}{6}.500000E+02 \PYG{l+m}{156}.788 \PYG{l+m}{335}.62
 \PYG{l+m}{6}.600000E+02 \PYG{l+m}{163}.6668 \PYG{l+m}{337}.48
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{An extra column name?} PISKaS produces one output for each compartment
declared in the model. Therefore, adding the name of the compartment as the
first column allows the code to identify the corresponding experimental data
with the simulated compartment and apply correctly the fitness function.
Finally, the model error is the sum of each fitness per compartment.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{About the example model:} The model has three parts: An equilibration of
600 seconds, then the model is modified to add a quantity of \sphinxcode{\sphinxupquote{L(r)}} agents,
and then perform the actual simulation for 60 seconds. Despite BNG2 and NFsim,
PISKaS reports the whole simulation, so to compare effectively, we must offset
the time of the experimental data by 600.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare a sbatch configuration file}

Use the following code as template to make a shell script and queue it with
sbatch. Note that the \sphinxcode{\sphinxupquote{export}} statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \sphinxcode{\sphinxupquote{python3}} redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}no\PYGZhy{}requeue}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}partition=cpu}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}ntasks=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task=1}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}job\PYGZhy{}name=pleione\PYGZhy{}piskas}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}output=stdout.txt}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}error=stderr.txt}

\PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}\PYG{l+s+s2}{:}\PYG{n+nv}{\PYGZdl{}HOME}\PYG{l+s+s2}{/opt/git\PYGZhy{}glucksfall\PYGZhy{}pleione\PYGZhy{}master}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nv}{MODEL}\PYG{o}{=}pysbmodel\PYGZhy{}example6\PYGZhy{}piskas.kappa
\PYG{n+nv}{FINAL}\PYG{o}{=}\PYG{l+m}{660}
\PYG{n+nv}{STEPS}\PYG{o}{=}\PYG{l+m}{66}

\PYG{n+nv}{PARTITION}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}PARTITION}
\PYG{n+nv}{DATA}\PYG{o}{=}../exp\PYGZhy{}data/piskas/data\PYGZhy{}*.txt

\PYG{n+nv}{NUM\PYGZus{}ITER}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{NUM\PYGZus{}SIMS}\PYG{o}{=}\PYG{l+m}{10}
\PYG{n+nv}{POP\PYGZus{}SIZE}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{POP\PYGZus{}BEST}\PYG{o}{=}\PYG{l+m}{0}

\PYG{n+nv}{SWAP}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{RATE}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{ERROR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}MWUT\PYGZdq{}}
\PYG{n+nv}{UTABLE}\PYG{o}{=}./ucrit.txt

python3 \PYGZhy{}m pleione.piskas \PYGZhy{}\PYGZhy{}model\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MODEL} \PYGZhy{}\PYGZhy{}final\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}FINAL} \PYGZhy{}\PYGZhy{}steps\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}STEPS} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}iter\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}ITER} \PYGZhy{}\PYGZhy{}pops\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}SIZE} \PYGZhy{}\PYGZhy{}sims\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}SIMS} \PYGZhy{}\PYGZhy{}best\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}BEST} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}data\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}DATA} \PYGZhy{}\PYGZhy{}rate\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RATE} \PYGZhy{}\PYGZhy{}swap\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SWAP} \PYGZhy{}\PYGZhy{}error\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}ERROR} \PYGZhy{}\PYGZhy{}crit\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}UTABLE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}slurm\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PARTITION}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{sbatch or python multiproccesing?} To execute Pleione outside a SLURM
queue, simple execute the shell script with \sphinxcode{\sphinxupquote{sh}}, \sphinxcode{\sphinxupquote{bash}} or any shell
interpreter without the \sphinxcode{\sphinxupquote{slurm}} option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need help?} type \sphinxcode{\sphinxupquote{python3 -m pleione.piskas -{-}help}} to find out the
available command options.
\end{sphinxadmonition}

Parameterization of BioNetGen language Rule-Based Models


\section{Parameterization with BioNetGen2}
\label{\detokenize{engines/bng2:parameterization-with-bionetgen2}}\label{\detokenize{engines/bng2::doc}}\begin{enumerate}
\item {} 
\sphinxstylestrong{Prepare the model}

Pleione parmeterization methods find which variables will be calibrated using
the symbol \sphinxcode{\sphinxupquote{\#}} (number sign, hash or pound sign) followed by:
\begin{itemize}
\item {} 
An initial distribution type: \sphinxcode{\sphinxupquote{uniform}}, \sphinxcode{\sphinxupquote{loguniform}}, \sphinxcode{\sphinxupquote{lognormal}}

\item {} 
An initial search space: \sphinxcode{\sphinxupquote{{[}min max{]}}} or \sphinxcode{\sphinxupquote{{[}mean standard\_deviation{]}}}
in the case \sphinxcode{\sphinxupquote{lognormal}} was selected.

\item {} 
A type of mutation: \sphinxcode{\sphinxupquote{uniform}} or \sphinxcode{\sphinxupquote{loguniform}} to use a new search
space; or \sphinxcode{\sphinxupquote{factor}} to perform a local mutation search

\item {} 
A search space for mutated parameters: \sphinxcode{\sphinxupquote{{[}min max{]}}} or
\sphinxcode{\sphinxupquote{{[}probability fold\_change{]}}}

\item {} 
An optional mutation rate per parameter. Without it, a global mutation
rate is used.

\end{itemize}

For instace:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
KD1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
km1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
K2RT\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}       \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
km2\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
kphos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}      \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
kdephos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}    \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Factor mutation:} This type of mutation strategy comes from BioNetFit and
selects a random value from the range \sphinxcode{\sphinxupquote{0.9 * old\_value, 1.1 * old\_value}}
if the declared value is \sphinxcode{\sphinxupquote{0.1}} with probability \sphinxcode{\sphinxupquote{0.2}}.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare the data files}

BNG2 produce simulations files with the following format. Please prepare
data files with the same format, including the initial space in each row.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}          time         RLbonds              pR}
 \PYG{l+m}{0}.00000000E+00  \PYG{l+m}{0}.00000000E+00  \PYG{l+m}{3}.55300000E+02
 \PYG{l+m}{1}.00000000E+01  \PYG{l+m}{1}.14072000E+02  \PYG{l+m}{3}.56440000E+02
 \PYG{l+m}{2}.00000000E+01  \PYG{l+m}{1}.39183800E+02  \PYG{l+m}{3}.49960000E+02
 \PYG{l+m}{3}.00000000E+01  \PYG{l+m}{1}.49153400E+02  \PYG{l+m}{3}.43980000E+02
 \PYG{l+m}{4}.00000000E+01  \PYG{l+m}{1}.56868400E+02  \PYG{l+m}{3}.42600000E+02
 \PYG{l+m}{5}.00000000E+01  \PYG{l+m}{1}.56788000E+02  \PYG{l+m}{3}.35620000E+02
 \PYG{l+m}{6}.00000000E+01  \PYG{l+m}{1}.63666800E+02  \PYG{l+m}{3}.37480000E+02
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
\sphinxstylestrong{Prepare a sbatch configuration file}

Use the following code as template to make a shell script and queue it with
sbatch. Note that the \sphinxcode{\sphinxupquote{export}} statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \sphinxcode{\sphinxupquote{python3}} redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}
\PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}\PYG{l+s+s2}{:}\PYG{n+nv}{\PYGZdl{}HOME}\PYG{l+s+s2}{/opt/git\PYGZhy{}glucksfall\PYGZhy{}pleione\PYGZhy{}master}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}no\PYGZhy{}requeue}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}partition=cpu}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}ntasks=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task=1}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}job\PYGZhy{}name=pleione\PYGZhy{}bng2}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}output=stdout.txt}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}error=stderr.txt}

\PYG{n+nv}{MODEL}\PYG{o}{=}pysbmodel\PYGZhy{}example6\PYGZhy{}bng2.bngl \PYG{c+c1}{\PYGZsh{} the model should have the .bngl extension}

\PYG{n+nv}{PARTITION}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}PARTITION}
\PYG{n+nv}{DATA}\PYG{o}{=}../exp\PYGZhy{}data/bng2/data\PYGZhy{}*.txt

\PYG{n+nv}{NUM\PYGZus{}ITER}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{NUM\PYGZus{}SIMS}\PYG{o}{=}\PYG{l+m}{10}
\PYG{n+nv}{POP\PYGZus{}SIZE}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{POP\PYGZus{}BEST}\PYG{o}{=}\PYG{l+m}{0}

\PYG{n+nv}{SWAP}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{RATE}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{ERROR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}MWUT\PYGZdq{}}
\PYG{n+nv}{UTABLE}\PYG{o}{=}./ucrit.txt

python3 \PYGZhy{}m pleione.bng2 \PYGZhy{}\PYGZhy{}model\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MODEL} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}iter\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}ITER} \PYGZhy{}\PYGZhy{}pops\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}SIZE} \PYGZhy{}\PYGZhy{}sims\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}SIMS} \PYGZhy{}\PYGZhy{}best\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}BEST} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}data\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}DATA} \PYGZhy{}\PYGZhy{}rate\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RATE} \PYGZhy{}\PYGZhy{}swap\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SWAP} \PYGZhy{}\PYGZhy{}error\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}ERROR} \PYGZhy{}\PYGZhy{}crit\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}UTABLE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}slurm\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PARTITION}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{sbatch or python multiproccesing?} To execute Pleione outside a SLURM
queue, simple execute the shell script with \sphinxcode{\sphinxupquote{sh}}, \sphinxcode{\sphinxupquote{bash}} or any shell
interpreter without the \sphinxcode{\sphinxupquote{slurm}} option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need help?} type \sphinxcode{\sphinxupquote{python3 -m pleione.bng2 -{-}help}} to find out the
available command options.
\end{sphinxadmonition}


\section{Parameterization with NFsim}
\label{\detokenize{engines/nfsim:parameterization-with-nfsim}}\label{\detokenize{engines/nfsim::doc}}\begin{enumerate}
\item {} 
\sphinxstylestrong{Prepare the model}

Pleione parmeterization methods find which variables will be calibrated using
the symbol \sphinxcode{\sphinxupquote{\#}} (number sign, hash or pound sign) followed by:
\begin{itemize}
\item {} 
An initial distribution type: \sphinxcode{\sphinxupquote{uniform}}, \sphinxcode{\sphinxupquote{loguniform}}, \sphinxcode{\sphinxupquote{lognormal}}

\item {} 
An initial search space: \sphinxcode{\sphinxupquote{{[}min max{]}}} or \sphinxcode{\sphinxupquote{{[}mean standard\_deviation{]}}}
in the case \sphinxcode{\sphinxupquote{lognormal}} was selected.

\item {} 
A type of mutation: \sphinxcode{\sphinxupquote{uniform}} or \sphinxcode{\sphinxupquote{loguniform}} to use a new search
space; or \sphinxcode{\sphinxupquote{factor}} to perform a local mutation search

\item {} 
A search space for mutated parameters: \sphinxcode{\sphinxupquote{{[}min max{]}}} or
\sphinxcode{\sphinxupquote{{[}probability fold\_change{]}}}

\item {} 
An optional mutation rate per parameter. Without it, a global mutation
rate is used.

\end{itemize}

For instace:

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
KD1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
km1\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
K2RT\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}       \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
km2\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}        \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
kphos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}      \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
kdephos\PYGZus{}\PYGZus{}FREE\PYGZus{}\PYGZus{}    \PYG{l+m}{1}.000000e+00 \PYG{c+c1}{\PYGZsh{} loguniform[0.01 100] factor[0.2 0.1]}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Factor mutation:} This type of mutation strategy comes from BioNetFit and
selects a random value from the range \sphinxcode{\sphinxupquote{0.9 * old\_value, 1.1 * old\_value}}
if the declared value is \sphinxcode{\sphinxupquote{0.1}} with probability \sphinxcode{\sphinxupquote{0.2}}.
\end{sphinxadmonition}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare the data files}

NFsim produce simulations files with the following format. Please prepare
data files with the same format to avoid incompatibilities.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
time, RLbonds, pR
\PYG{l+m}{0}.00000000E+00, \PYG{l+m}{0}.00000000E+00, \PYG{l+m}{3}.55300000E+02
\PYG{l+m}{1}.00000000E+01, \PYG{l+m}{1}.14072000E+02, \PYG{l+m}{3}.56440000E+02
\PYG{l+m}{2}.00000000E+01, \PYG{l+m}{1}.39183800E+02, \PYG{l+m}{3}.49960000E+02
\PYG{l+m}{3}.00000000E+01, \PYG{l+m}{1}.49153400E+02, \PYG{l+m}{3}.43980000E+02
\PYG{l+m}{4}.00000000E+01, \PYG{l+m}{1}.56868400E+02, \PYG{l+m}{3}.42600000E+02
\PYG{l+m}{5}.00000000E+01, \PYG{l+m}{1}.56788000E+02, \PYG{l+m}{3}.35620000E+02
\PYG{l+m}{6}.00000000E+01, \PYG{l+m}{1}.63666800E+02, \PYG{l+m}{3}.37480000E+02
\end{sphinxVerbatim}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
\sphinxstylestrong{Prepare a sbatch configuration file}

Use the following code as template to make a shell script and queue it with
sbatch. Note that the \sphinxcode{\sphinxupquote{export}} statement is inside the code to tell SLURM
to add the path and ensure proper execution when pleione was cloned with
git. Also, \sphinxcode{\sphinxupquote{python3}} redirects to either the system installed executable
(with pandas installed either as admin or user) or redirects to the user
compiled executable if an alias exists for it.

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/sh}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}no\PYGZhy{}requeue}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}partition=cpu}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}nodes=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}ntasks=1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task=1}

\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}job\PYGZhy{}name=pleione\PYGZhy{}nfsim}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}output=stdout.txt}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}error=stderr.txt}

\PYG{n+nb}{export} \PYG{n+nv}{PYTHONPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}PYTHONPATH}\PYG{l+s+s2}{:}\PYG{n+nv}{\PYGZdl{}HOME}\PYG{l+s+s2}{/opt/git\PYGZhy{}glucksfall\PYGZhy{}pleione\PYGZhy{}master}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nv}{MODEL}\PYG{o}{=}pysbmodel\PYGZhy{}example6\PYGZhy{}nfsim.bngl \PYG{c+c1}{\PYGZsh{} the model should have the .bngl extension}
\PYG{n+nv}{FINAL}\PYG{o}{=}\PYG{l+m}{60}
\PYG{n+nv}{STEPS}\PYG{o}{=}\PYG{l+m}{6}

\PYG{n+nv}{PARTITION}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SLURM\PYGZus{}JOB\PYGZus{}PARTITION}
\PYG{n+nv}{DATA}\PYG{o}{=}../exp\PYGZhy{}data/nfsim/data\PYGZhy{}*.txt

\PYG{n+nv}{NUM\PYGZus{}ITER}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{NUM\PYGZus{}SIMS}\PYG{o}{=}\PYG{l+m}{10}
\PYG{n+nv}{POP\PYGZus{}SIZE}\PYG{o}{=}\PYG{l+m}{100}
\PYG{n+nv}{POP\PYGZus{}BEST}\PYG{o}{=}\PYG{l+m}{0}

\PYG{n+nv}{SWAP}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{RATE}\PYG{o}{=}\PYG{l+m}{0}.5
\PYG{n+nv}{ERROR}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}MWUT\PYGZdq{}}
\PYG{n+nv}{UTABLE}\PYG{o}{=}./ucrit.txt

python3 \PYGZhy{}m pleione.nfsim \PYGZhy{}\PYGZhy{}model\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}MODEL} \PYGZhy{}\PYGZhy{}final\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}FINAL} \PYGZhy{}\PYGZhy{}steps\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}STEPS} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}iter\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}ITER} \PYGZhy{}\PYGZhy{}pops\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}SIZE} \PYGZhy{}\PYGZhy{}sims\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}NUM\PYGZus{}SIMS} \PYGZhy{}\PYGZhy{}best\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}POP\PYGZus{}BEST} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}data\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}DATA} \PYGZhy{}\PYGZhy{}rate\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}RATE} \PYGZhy{}\PYGZhy{}swap\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}SWAP} \PYGZhy{}\PYGZhy{}error\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}ERROR} \PYGZhy{}\PYGZhy{}crit\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}UTABLE} \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}slurm\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PARTITION}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{sbatch or python multiproccesing?} To execute Pleione outside a SLURM
queue, simple execute the shell script with \sphinxcode{\sphinxupquote{sh}}, \sphinxcode{\sphinxupquote{bash}} or any shell
interpreter without the \sphinxcode{\sphinxupquote{slurm}} option. Be aware that, if SLURM is
running in the same machine, Pleione subprocess would impact negatively in
other user’s threads, and viceversa, since a cpu core could execute
concurrently two threads.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need help?} type \sphinxcode{\sphinxupquote{python3 -m pleione.nfsim -{-}help}} to find out the
available command options.
\end{sphinxadmonition}

Common to all parameterization methods, there are 9 algebraic objective
functions and one statistical function already implemented in the code.
Moreover, the code sort the models by their rank and therefore, ranks can be
added and sorted again, making the possibility to use a Multiple Objective
Genetic Algorithm.


\section{Model Validation}
\label{\detokenize{Validation:model-validation}}\label{\detokenize{Validation::doc}}
Pleione’s parameter calibration scripts call an external script to calculate
fitness to experimental data. You could use one of the following script to
calculate the fitness of your parameterized model against an independent
experimental data set:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pleione.bng2\PYGZhy{}doerror \PYGZhy{}\PYGZhy{}data foo \PYGZhy{}\PYGZhy{}sims bar \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}file output.txt \PYGZhy{}\PYGZhy{}error MWUT \PYGZhy{}\PYGZhy{}crit utable.txt
\end{sphinxVerbatim}

\sphinxstyleemphasis{OR}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pleione.kasim\PYGZhy{}doerror \PYGZhy{}\PYGZhy{}data foo \PYGZhy{}\PYGZhy{}sims bar \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}file output.txt \PYGZhy{}\PYGZhy{}error MWUT \PYGZhy{}\PYGZhy{}crit utable.txt
\end{sphinxVerbatim}

\sphinxstyleemphasis{OR}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pleione.nfsim\PYGZhy{}doerror \PYGZhy{}\PYGZhy{}data foo \PYGZhy{}\PYGZhy{}sims bar \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}file output.txt \PYGZhy{}\PYGZhy{}error MWUT \PYGZhy{}\PYGZhy{}crit utable.txt
\end{sphinxVerbatim}

\sphinxstyleemphasis{OR}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pleione.piskas\PYGZhy{}doerror \PYGZhy{}\PYGZhy{}data foo \PYGZhy{}\PYGZhy{}sims bar \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}\PYGZhy{}file output.txt \PYGZhy{}\PYGZhy{}error MWUT \PYGZhy{}\PYGZhy{}crit utable.txt
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Fitness Function}
Pleione currently support ten goodness of fit functions. To calculate more
than one function, include a comma-only separated list such as \sphinxcode{\sphinxupquote{MWUT,SSQ}}.
In doing so, this will calculate the contribution of both o more metrics to
the overall error and aid to validate of dischard a model calibration.
More information in {\hyperref[\detokenize{ObjectiveFunctions:fitneess-functions}]{\sphinxcrossref{\DUrole{std,std-ref}{Objective Functions}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need Help?}
Type \sphinxcode{\sphinxupquote{python3 -m pleione.\$STOCH\_ENGINE-doerror -{-}help}} where
\sphinxcode{\sphinxupquote{\$STOCH\_ENGINE}} can be the currently supported stochastic engines: BNG2,
NFsim, KaSim and PISKaS (all in lower cases, for instance \sphinxcode{\sphinxupquote{nfsim-doerror}})
\end{sphinxadmonition}


\section{Objective Functions}
\label{\detokenize{ObjectiveFunctions:objective-functions}}\label{\detokenize{ObjectiveFunctions:fitneess-functions}}\label{\detokenize{ObjectiveFunctions::doc}}
Common to all parameterization methods, there are 9 algebraic objective
functions and one statistical function already implemented in the code.
Moreover, the code sort the models by their rank and therefore, ranks can be
added and sorted again, making the possibility to use a Multiple Objective
Genetic Algorithm.


\subsection{Algebraic Objective Functions}
\label{\detokenize{functions/algebraics:algebraic-objective-functions}}\label{\detokenize{functions/algebraics::doc}}
Here are the formulas to calculate the error between multiple data sets and
simulations files.
\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Mean Square Error (MSE):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\left( \frac{1}{m} \sum_{i=1}^{m} \mathrm{exp}_i - \frac{1}{n} \sum_{j=1}^{n} \mathrm{sim}_j \right) ^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Mean Absolute Error (MAE):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\mathrm{abs} \left( \frac{1}{m} \sum_{i=1}^{m} \mathrm{exp}_i - \frac{1}{n} \sum_{j=1}^{n} \mathrm{sim}_j \right)\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Pair-Wise Square Deviation (PWSD):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\frac{1}{mn} \sum_{i=1}^{m} \sum_{j=1}^{n} \left({\mathrm{exp}_i - \mathrm{sim}_j } \right)^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Absolute Pair-Wise Deviation (APWSD):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\frac{1}{mn} \sum_{i=1}^{m} \sum_{j=1}^{n} \mathrm{abs} \left( \mathrm{exp}_i - \mathrm{sim}_j \right)\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Normalized Pair-Wise Square Deviation (NPWSD):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\frac{1}{mn} \sum_{i=1}^{m} \sum_{j=1}^{n} \left( \frac{ \mathrm{exp}_i - \mathrm{sim}_j }{ \mathrm{exp}_i } \right)^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Absolute Normalized Pair-Wise Deviation (ANPWSD):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\frac{1}{mn} \sum_{i=1}^{m} \sum_{j=1}^{n} \mathrm{abs} \left( \frac{ \mathrm{exp}_i - \mathrm{sim}_j }{ \mathrm{exp}_i } \right)\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Sum of SQuares (SSQ):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\sum_{i=1}^{m} \sum_{j=1}^{n} \left({\mathrm{exp}_i - \mathrm{sim}_j } \right)^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Chi-Square (CHISQ):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\sum_{i=1}^{m} \sum_{j=1}^{n} \left( \frac{ \mathrm{exp}_i - \mathrm{sim}_j }{ \sigma_{\mathrm{exp}} } \right)^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\item {} 
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Mean Normalized Square Error (MNSE):}
\item[] 
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\sum_{i=1}^{m} \sum_{j=1}^{n} \left( \frac{ \mathrm{exp}_i - \mathrm{sim}_j }{ \overline{\mathrm{exp}} } \right)^{2}\)
\end{DUlineblock}
\end{DUlineblock}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need a different Objective Function?} The code that calculates the error
is separated from the main Genetic Algorithm. This make useful to encode
other Objective Functions if the already implemented does not apply to your
necessities. You could contact us to add your function to the pleione
package.
\end{sphinxadmonition}


\subsection{Statistical Objective Functions}
\label{\detokenize{functions/statistical:statistical-objective-functions}}\label{\detokenize{functions/statistical::doc}}
We implemented the Mann-Whitney U-test (MWUT) to calculate the error between
experimental data and simulations. The U-test is a non-parametric statistical
test that, within a confidence level, determine if a stochastic repeated
measurements is identical or not to another repeated measurements.

1. We count how many times experimental data (\(exp_i\)) are larger than
simulated values (\(sim_j\)):
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{for} \(i \mathrm{\ in\ } \mathrm{range} ( \mathrm{len}(exp) )\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{for} \(j \mathrm{\ in\ } \mathrm{range} ( \mathrm{len}(sim) )\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{if} \(exp_{i} > sim_{j}\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(U_{exp} \gets U_{exp} + 1.0\)
\end{DUlineblock}
\item[] \sphinxstylestrong{else if} \(exp_{i} < sim_{j}\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(U_{sim} \gets U_{sim} + 1.0\)
\end{DUlineblock}
\item[] \sphinxstylestrong{else}:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(U_{exp} \gets U_{exp} + 0.5\)
\item[] \(U_{sim} \gets U_{sim} + 0.5\)
\end{DUlineblock}
\end{DUlineblock}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
We determine if \(U_{exp}\) is statistically significant:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{for} \(i \mathrm{\ in\ } \mathrm{range} ( \mathrm{len}(exp) )\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{if} \(\mathrm{len}(exp) \times \mathrm{len}(sim) - \mathrm{min}(U_{exp}, U_{sim}) \leq U_{\mathrm{critic}}\):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \(\mathrm{\textit{null}\ hypothesis,\ }H_{0}\mathrm{,\ is\ rejected}\)
\item[] \(U_{\mathrm{model}} \gets U_{\mathrm{model}} + 1.0\)
\end{DUlineblock}
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The U-test is the only fitness function that has known limits: For a
\sphinxstyleemphasis{perfect} model, the U-test is zero. A complete wrong model will have a
\(U_{model}\) equal to the number of Observables times the number of
experimental time points. For instance, the example model we use to compare
with BioNetFit has 2 Observables and 7 experimental time points, then a max
\(U_{model}\) equal to 14.
\end{sphinxadmonition}


\subsection{Multiple Objective Functions}
\label{\detokenize{functions/multiple:multiple-objective-functions}}\label{\detokenize{functions/multiple::doc}}
A Multiple Objective Function is build from two or more fitness functions.
Firstly, a fitness is calculated and all models ranked. Then, the next fitness.
Finally, the sum of ranks is use to rank agains the models.

Algoritmically:
\begin{equation*}
\begin{split}rank_1 &= \mathrm{sort\ models\ following\ function\ 1} \\
&\mathrel{\vdots} \\
rank_n &= \mathrm{sort\ models\ following\ function\ n} \\
\\
rank_{MO} &= \mathrm{sort\ models\ following\ } (rank_1 + \ldots + rank_n)\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
We currently don’t provide weights to rank the models. Be aware that, if you
use multiple algebraic functions and the statistical fitness function, the
importance of the statistical function is diluited.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Need a different Objective Function?}
The code that calculates the error is separated from the main Genetic
Algorithm. This make useful to encode other Objective Functions if the
already implemented does not apply to your necessities. You could contact us
to add your function to the pleione package.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxstylestrong{Installation instructions:}
Instructions to install KaSim, BioNetGen, NFsim, and PISKaS are
available in their source code webpages. Nonetheless, here you will find
basic information to clone using git or download the software and install
it.

To install SLURM, you should have admin access to your infrastructure and an
UNIX-based OS. Detailed instructions are provided here:
{\hyperref[\detokenize{SLURM:slurm-instructions}]{\sphinxcrossref{\DUrole{std,std-ref}{Installing SLURM in your machine}}}}
\end{sphinxadmonition}


\chapter{Compiling Python3 from source}
\label{\detokenize{Python3:compiling-python3-from-source}}\label{\detokenize{Python3::doc}}
If you don’t have admin access to the cluster configuration, you could compile
and install python3 from source following these instructions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget https://www.python.org/ftp/python/3.6.5/Python\PYGZhy{}3.6.5.tgz \PYG{l+s+se}{\PYGZbs{}}
\PYGZhy{}O \PYGZti{}/opt/ubuntu\PYGZhy{}software/Python\PYGZhy{}3.6.5.tgz
\PYG{k}{if} \PYG{o}{[} \PYGZhy{}d \PYGZti{}/opt/Python\PYGZhy{}3.6.5 \PYG{o}{]}\PYG{p}{;} \PYG{k}{then} rm \PYGZhy{}rf \PYGZti{}/opt/Python\PYGZhy{}3.6.5\PYG{p}{;} \PYG{k}{fi}
tar xvzf \PYGZti{}/opt/ubuntu\PYGZhy{}software/Python\PYGZhy{}3.6.5.tgz \PYGZhy{}C \PYGZti{}/opt
\PYG{n+nb}{cd} \PYGZti{}/opt/Python\PYGZhy{}3.6.5
\PYG{k}{if} \PYG{o}{[} \PYGZhy{}f Makefile \PYG{o}{]}\PYG{p}{;} \PYG{k}{then} make clean\PYG{p}{;} \PYG{k}{fi}
\PYG{k}{if} \PYG{o}{[} \PYGZhy{}d \PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/opt/python\PYGZhy{}3.6.5 \PYG{o}{]}\PYG{p}{;} \PYG{k}{then} rm \PYGZhy{}rf \PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/opt/python\PYGZhy{}3.6.5\PYG{p}{;} \PYG{k}{fi}
./configure \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}\PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/opt/python\PYGZhy{}3.6.5
make
make install
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Don’t copy an installation folder from another machine since there may be
libraries incompatibilities. Instead, the code will download, configure,
compile, and install. To make accesible from anywhere, you could add an
alias into \sphinxcode{\sphinxupquote{\textasciitilde{}/.bashrc}} or a symbolic in your \sphinxcode{\sphinxupquote{\$HOME/bin}} folder for
\sphinxcode{\sphinxupquote{\$HOME/opt/python-3.6.5/bin/python3}} and \sphinxcode{\sphinxupquote{pip3}}.
\end{sphinxadmonition}

To install numpy and pandas use the following instructions, in order since some
pandas dependencies has also dependencies:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget https://files.pythonhosted.org/packages/71/90/ca61e203e0080a8cef7ac21eca199829fa8d997f7c4da3e985b49d0a107d/numpy\PYGZhy{}1.14.3\PYGZhy{}cp36\PYGZhy{}cp36m\PYGZhy{}manylinux1\PYGZus{}x86\PYGZus{}64.whl
wget https://files.pythonhosted.org/packages/dc/83/15f7833b70d3e067ca91467ca245bae0f6fe56ddc7451aa0dc5606b120f2/pytz\PYGZhy{}2018.4\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
wget https://files.pythonhosted.org/packages/67/4b/141a581104b1f6397bfa78ac9d43d8ad29a7ca43ea90a2d863fe3056e86a/six\PYGZhy{}1.11.0\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
wget https://files.pythonhosted.org/packages/cf/f5/af2b09c957ace60dcfac112b669c45c8c97e32f94aa8b56da4c6d1682825/python\PYGZus{}dateutil\PYGZhy{}2.7.3\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
wget https://files.pythonhosted.org/packages/69/ec/8ff0800b8594691759b78a42ccd616f81e7099ee47b167eb9bbd502c02b9/pandas\PYGZhy{}0.23.0\PYGZhy{}cp36\PYGZhy{}cp36m\PYGZhy{}manylinux1\PYGZus{}x86\PYGZus{}64.whl

pip3 install numpy\PYGZhy{}1.14.3\PYGZhy{}cp36\PYGZhy{}cp36m\PYGZhy{}manylinux1\PYGZus{}x86\PYGZus{}64.whl
pip3 install pytz\PYGZhy{}2018.4\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
pip3 install six\PYGZhy{}1.11.0\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
pip3 install python\PYGZus{}dateutil\PYGZhy{}2.7.3\PYGZhy{}py2.py3\PYGZhy{}none\PYGZhy{}any.whl
pip3 install pandas\PYGZhy{}0.23.0\PYGZhy{}cp36\PYGZhy{}cp36m\PYGZhy{}manylinux1\PYGZus{}x86\PYGZus{}64.whl
\end{sphinxVerbatim}

If you have admin access (and willing to compile python3 from source) you could
install the following dependencies:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
apt\PYGZhy{}get install libssl\PYGZhy{}dev zlib1g\PYGZhy{}dev libncurses5\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
libncursesw5\PYGZhy{}dev libreadline\PYGZhy{}dev libsqlite3\PYGZhy{}dev libgdbm\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
libdb5.3\PYGZhy{}dev libbz2\PYGZhy{}dev libexpat1\PYGZhy{}dev liblzma\PYGZhy{}dev tk\PYGZhy{}dev
\end{sphinxVerbatim}

Compiling python3 with all dependencies would make installation of packages
easier. Just follow the instructions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip3 install pandas
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Installing pandas with pip will install numpy as its dependency.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Be sure you are calling pip3 after creating an alias or a symbolic link.
Without admin credentials, pip3 would fail to install pandas.
\end{sphinxadmonition}


\chapter{Installing SLURM in your machine}
\label{\detokenize{SLURM:installing-slurm-in-your-machine}}\label{\detokenize{SLURM:slurm-instructions}}\label{\detokenize{SLURM::doc}}
To install SLURM you need admin access to the machine. Please follow this
instructions to start up running the workload manager, in the controller as well
in the controlled machines.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get \PYGZhy{}y install slurm\PYGZhy{}wlm
sudo nano /etc/slurm\PYGZhy{}llnl/slurm.conf

sudo chown \PYGZhy{}R slurm:slurm /var/run/slurm\PYGZhy{}llnl/
sudo chown \PYGZhy{}R slurm:slurm /var/lib/slurm\PYGZhy{}llnl/
sudo chown \PYGZhy{}R slurm:slurm /var/log/slurm\PYGZhy{}llnl/
sudo mkdir /var/spool/slurmd
sudo chown \PYGZhy{}R slurm:slurm /var/spool/slurmd

sudo systemctl start slurmd
\end{sphinxVerbatim}

Replace \sphinxcode{\sphinxupquote{\$HOST\_NAME}} with your machine name that is going to act as the
controller. If you have multiple machines, this configuration file must be
identical and in all machines in the queue.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}\PYGZsh{}\PYGZsh{} slurm.\PYG{k}{conf} \PYG{p}{\PYGZhy{}} Slurm config \PYG{k}{file}.

\PYGZsh{}ClusterName\PYG{p}{=}\PYGZdl{}HOST\PYGZus{}NAME
ControlMachine\PYG{p}{=}\PYGZdl{}HOST\PYGZus{}NAME
SlurmUser\PYG{p}{=}slurm
AuthType\PYG{p}{=}auth/munge

SlurmctldPidFile\PYG{p}{=}\PYG{l+s+sr}{/var/}run\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmctld.pid
SlurmdPidFile\PYG{p}{=}\PYG{l+s+sr}{/var/}run\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmd.pid
SlurmdSpoolDir\PYG{p}{=}\PYG{l+s+sr}{/var/}lib\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmd
StateSaveLocation\PYG{p}{=}\PYG{l+s+sr}{/var/}lib\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmctld

SwitchType\PYG{p}{=}switch/none
ProctrackType\PYG{p}{=}proctrack/pgid
TaskPlugin\PYG{p}{=}task/none

MpiDefault\PYG{p}{=}none
MaxJobCount\PYG{p}{=}\PYG{l+m}{100000}
MaxArraySize\PYG{p}{=}\PYG{l+m}{64000}

\PYGZsh{} TIMERS
SlurmdTimeout\PYG{p}{=}\PYG{l+m}{300}
InactiveLimit\PYG{p}{=}\PYG{l+m}{0}
MinJobAge\PYG{p}{=}\PYG{l+m}{300}
KillWait\PYG{p}{=}\PYG{l+m}{30}
Waittime\PYG{p}{=}\PYG{l+m}{0}

\PYGZsh{} SCHEDULING
SchedulerType\PYG{p}{=}sched/backfill
SelectType\PYG{p}{=}select/cons\PYGZus{}res
SelectTypeParameters\PYG{p}{=}CR\PYGZus{}Core
FastSchedule\PYG{p}{=}\PYG{l+m}{1}

\PYGZsh{} LOGGING
SlurmctldDebug\PYG{p}{=}\PYG{l+m}{3}
SlurmctldLogFile\PYG{p}{=}\PYG{l+s+sr}{/var/}log\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmctld.log
SlurmdDebug\PYG{p}{=}\PYG{l+m}{3}
SlurmdLogFile\PYG{p}{=}\PYG{l+s+sr}{/var/}log\PYG{l+s+sr}{/slurm\PYGZhy{}llnl/}slurmd.log

\PYGZsh{} COMPUTE NODES

\PYGZsh{} Here you add the machine hardware configurations
NodeName\PYG{p}{=}\PYGZdl{}HOST\PYGZus{}NAME Procs\PYG{p}{=}\PYG{l+m}{8} Boards\PYG{p}{=}\PYG{l+m}{1} SocketsPerBoard\PYG{p}{=}\PYG{l+m}{1} CoresPerSocket\PYG{p}{=}\PYG{l+m}{4} ThreadsPerCore\PYG{p}{=}\PYG{l+m}{2} State\PYG{p}{=}idle

\PYGZsh{} Here you add the machine\PYG{p}{(}s\PYG{p}{)} \PYG{k}{to} \PYG{k}{a} Partition
PartitionName\PYG{p}{=}MyCluster Nodes\PYG{p}{=}\PYGZdl{}HOST\PYGZus{}NAME Default\PYG{p}{=}yes MaxTime\PYG{p}{=}INFINITE State\PYG{p}{=}\PYG{k}{up}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Please refer to \sphinxhref{https://slurm.schedmd.com/}{SLURM} for advance configuration like limiting time, CPUs
and RAM for users or groups, to balance load in your cluster.
\end{sphinxadmonition}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}